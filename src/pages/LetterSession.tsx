import { useNavigate, useParams } from 'react-router-dom';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { useEffect, useRef, useState } from 'react';
import { Hands } from '@mediapipe/hands';
import { Camera } from '@mediapipe/camera_utils';
import { drawLandmarks, drawOverlayMessage } from '../components/draw/draw';
import { detectGesture } from '../components/draw/RightDetector';
import API from '@/components/AxiosInstance';
import SessionHeader from '@/components/SessionHeader';
import LetterDisplay from '@/components/LetterDisplay';

const LetterSession = () => {
  const [gesture, setGesture] = useState<string | null>(null);
  const navigate = useNavigate();
  const { setType,qOrs } = useParams();
  const [sets] = useState(() => {
    if (setType === 'consonant') {
      return ['„Ñ±', '„Ñ¥', '„Ñ∑', '„Ñπ','„ÖÅ','„ÖÇ','„ÖÖ','„Öá','„Öà','„Öä','„Öã','„Öå','„Öç','„Öé'];
    } else if (setType === 'vowel') {
      return ['„Öè', '„Öë', '„Öì', '„Öï','„Öó','„Öõ','„Öú','„Ö†','„Ö°','„Ö£'];
    } else {
      return [];
    }
  });
  const sendQuizResult = async () => {
    const passedLetters = JSON.parse(localStorage.getItem('passed') || '[]');
    const failedLetters = JSON.parse(localStorage.getItem('failed') || '[]');

    try {
      await API.post(
        'learning/result/letter',
        {
          passed: passedLetters,
          failed: failedLetters,
        },
        {
          withCredentials: true, // ‚úÖ Ïø†ÌÇ§ Ìè¨Ìï®
        }
      );
      console.log("Í≤∞Í≥º Ï†ÑÏÜ° ÏôÑÎ£å");
      // ÏÑ†ÌÉù: localStorage Ï¥àÍ∏∞Ìôî
      localStorage.removeItem('passed');
      localStorage.removeItem('failed');
    } catch (error) {
      console.error("Í≤∞Í≥º Ï†ÑÏÜ° Ïã§Ìå®", error);
    }
  };
  const [currentIndex, setCurrentIndex] = useState(0);
  const [progressPercent, setProgressPercent] = useState(0);
  const [isDone, setIsDone] = useState(false);

  const times = useRef(10);
  const qors = useRef<boolean>(qOrs === 'quiz');
  const timeref = useRef<HTMLDivElement | null>(null);
  const videoRef = useRef<HTMLVideoElement | null>(null);
  const canvasRef = useRef<HTMLCanvasElement | null>(null);
  const resultRef = useRef<HTMLDivElement | null>(null);
  const decref = useRef<HTMLDivElement | null>(null);
  const pileref = useRef<HTMLDivElement | null>(null);

  const ges = useRef<string | null>(null);
  const pges = useRef<string | null>(null);
  const std = useRef<boolean>(false);
  const navigated = useRef<boolean>(false);

  const [words, setWords] = useState('');

  const handleNext = () => {
    setProgressPercent(0);
    if (currentIndex < sets.length - 1) {
      setCurrentIndex(currentIndex + 1);
    }
  };
  


  const timedown = () => {
    if (times.current === 1) {
      times.current -= 1;
      std.current = false;
      navigated.current = true;
      if (decref.current) decref.current.textContent = 'Ïã§Ìå®';
      if (timeref.current) timeref.current.textContent = times.current.toString();

      const failedChar = sets[currentIndex];
      const prevFailed = JSON.parse(localStorage.getItem('failed') || '[]');

      const newFailed = prevFailed.filter((c: string) => c !== failedChar);
      newFailed.push(failedChar);

      localStorage.setItem('failed', JSON.stringify(newFailed));

      setIsDone(true);
      setTimeout(handleNext, 2000);
    } else if (times.current > 1) {
      times.current -= 1;
      if (timeref.current) {
        timeref.current.textContent = times.current.toString();
      }
    }

    if (std.current) {
      setTimeout(timedown, 1000);
    }
  };

  const divword = (word: string) => {
    if (!decref.current || !pileref.current) return;
    decref.current.textContent = '';
    setIsDone(false);
    for (let i = 0; i < word.length; i++) {
      const char = word[i];
      const code = char.charCodeAt(0);
      if (code >= 0x3131 && code <= 0x318E) {
        decref.current.textContent += char;
      }
    }
    pileref.current.textContent = '';
    if(qors.current){
      times.current = 10;
      if (timeref.current) timeref.current.textContent = times.current.toString();
    }
  };

// ÌÉÄÏù¥Î®∏ Í¥ÄÎ†® ÏÉÅÌÉú Ï∂îÍ∞Ä
const [gestureRecognitionActive, setGestureRecognitionActive] = useState(false);
const gestureTimerRef = useRef<NodeJS.Timeout | null>(null);
const startTimeRef = useRef<number | null>(null);

useEffect(() => {
  pges.current = ges.current;
    navigated.current = false;
    setProgressPercent(0);
    
  if (pges.current != null && ges.current != null) {
    if ( pges.current === ges.current &&
      decref.current?.textContent?.[0] === pges.current
    ) {

      // Ïù¥ÎØ∏ ÌÉÄÏù¥Î®∏Í∞Ä Ïã§Ìñâ Ï§ëÏù¥ ÏïÑÎãàÎùºÎ©¥ ÌÉÄÏù¥Î®∏ ÏãúÏûë
      if (!gestureTimerRef.current) {
        console.log("Ï†úÏä§Ï≤ò Ïù∏Ïãù ÏãúÏûë:", ges.current);
        setGestureRecognitionActive(true);
        startTimeRef.current = Date.now();
        
        // ÌîÑÎ°úÍ∑∏Î†àÏä§ Î∞î Ïï†ÎãàÎ©îÏù¥ÏÖò ÏãúÏûë
        const updateProgress = () => {
          if (!startTimeRef.current) return;
          
          const elapsed = Date.now() - startTimeRef.current;
          const percent = Math.min((elapsed / 800) * 100, 100);
          setProgressPercent(percent);
          
          if (percent < 100) {
            requestAnimationFrame(updateProgress);
          }
        };
        
        requestAnimationFrame(updateProgress);
        
        // 0.6Ï¥à ÌÉÄÏù¥Î®∏ ÏÑ§Ï†ï
        gestureTimerRef.current = setTimeout(() => {
          console.log("0.6Ï¥à Ïú†ÏßÄ ÏÑ±Í≥µ! Ï†úÏä§Ï≤ò:", ges.current);
          setProgressPercent(100);
          
          // Ïó¨Í∏∞ÏÑú Ï†úÏä§Ï≤ò Ïù∏Ïãù ÏÑ±Í≥µ Ï≤òÎ¶¨
          if (pileref.current && decref.current?.textContent) {
            pileref.current.textContent += pges.current;
            decref.current.textContent = decref.current.textContent.replace(pges.current!, '');
            
            if (decref.current.textContent === '' && !navigated.current) {
              std.current = false;
              navigated.current = true;
              decref.current.textContent = 'ÌÜµÍ≥º';
              setIsDone(true);
              
              const passedChar = sets[currentIndex];
              const prevPassed = JSON.parse(localStorage.getItem('passed') || '[]');
              const newPassed = prevPassed.filter((c: string) => c !== passedChar);
              newPassed.push(passedChar);
              localStorage.setItem('passed', JSON.stringify(newPassed));
              
              setTimeout(handleNext, 2000);
            }
          }
          
          // ÌÉÄÏù¥Î®∏ Ï¥àÍ∏∞Ìôî
          gestureTimerRef.current = null;
          setGestureRecognitionActive(false);
          
          pges.current = null;
        }, 800);
      }
    } else {
      // Ï†úÏä§Ï≤òÍ∞Ä Î≥ÄÍ≤ΩÎêòÏóàÍ±∞ÎÇò ÏùºÏπòÌïòÏßÄ ÏïäÏúºÎ©¥ ÌÉÄÏù¥Î®∏ Ï∑®ÏÜå
      if (gestureTimerRef.current) {
        clearTimeout(gestureTimerRef.current);
        gestureTimerRef.current = null;
        setGestureRecognitionActive(false);
        setProgressPercent(0);
        console.log("Ï†úÏä§Ï≤ò Î≥ÄÍ≤ΩÏúºÎ°ú Ïù∏Ïãù Ï∑®ÏÜå");
      }
    }
  } else {
    // Ï†úÏä§Ï≤òÍ∞Ä ÏóÜÏúºÎ©¥ ÌÉÄÏù¥Î®∏ Ï∑®ÏÜå
    if (gestureTimerRef.current) {
      clearTimeout(gestureTimerRef.current);
      gestureTimerRef.current = null;
      setGestureRecognitionActive(false);
      setProgressPercent(0);
      console.log("Ï†úÏä§Ï≤ò ÏóÜÏùåÏúºÎ°ú Ïù∏Ïãù Ï∑®ÏÜå");
    }
  }
  
  // Ïª¥Ìè¨ÎÑåÌä∏ Ïñ∏ÎßàÏö¥Ìä∏ Ïãú ÌÉÄÏù¥Î®∏ Ï†ïÎ¶¨
  return () => {
    if (gestureTimerRef.current) {
      clearTimeout(gestureTimerRef.current);
      gestureTimerRef.current = null;
    }
  };
}, [gesture]); // eslint-disable-line react-hooks/exhaustive-deps

  useEffect(() => {
    setWords(sets[currentIndex]);
  }, [currentIndex]);

  useEffect(() => {
    if (!words) return;
    std.current = true;
    divword(words);
    
    if(qors.current){
      setTimeout(timedown, 1000);
    }
  }, [words]);

  useEffect(() => {
    const videoElement = videoRef.current;
    const canvasElement = canvasRef.current;
    const resultElement = resultRef.current;

    if (!videoElement || !canvasElement || !resultElement) return;
    const canvasCtx = canvasElement.getContext('2d');
    if (!canvasCtx) return;

    const hands = new Hands({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`,
    });

    hands.setOptions({
      maxNumHands: 2,
      modelComplexity: 1,
      minDetectionConfidence: 0.7,
      minTrackingConfidence: 0.7,
    });

    hands.onResults((results: any) => {
      canvasCtx.save();
      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
      canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

      if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        const landmarks = results.multiHandLandmarks[0];
        const handvc = Math.sqrt(
          (landmarks[0].y - landmarks[9].y) ** 2 +
          (landmarks[0].x - landmarks[9].x) ** 2
        );

        if (handvc > 0.13 && handvc <= 0.5) {
          drawLandmarks(canvasCtx, landmarks, canvasElement);
          const gesture = detectGesture(landmarks);
          if (gesture) {
            resultElement.textContent = `üñêÔ∏è ${gesture}`;
            ges.current = gesture;
            setGesture(gesture);
          } else {
            resultElement.textContent = 'Hand detected';
            ges.current = null;
            setProgressPercent(0);
            setGesture(null);
          }
        } else {
          drawOverlayMessage(
            canvasCtx,
            canvasElement,
            handvc <= 0.13 ? 'ÏÜêÏùÑ ÏïûÏúºÎ°ú ÏòÆÍ≤®Ï£ºÏÑ∏Ïöî' : 'ÏÜêÏùÑ Îí§Î°ú ÎπºÏ£ºÏÑ∏Ïöî'
          );
          ges.current = null;
        }
      } else {
        resultElement.textContent = 'Waiting for hand...';
        setProgressPercent(0);
      }
      canvasCtx.restore();
    });

    const camera = new Camera(videoElement, {
      onFrame: async () => {
        await hands.send({ image: videoElement });
      },
      width: 640,
      height: 480,
    });

    camera.start();
  }, []);

  const progress = (currentIndex / sets.length) * 100;

  if(isDone && currentIndex === sets.length - 1)
  {
      return (
          <div className="flex items-center justify-center min-h-screen">
        <div className="text-center">
          <h1 className="text-xl font-bold text-gray-800 mb-2">ÎÅùÎÇ¥Ï§ÄÎã§!!</h1>
          <Button onClick={() => navigate('/home')}>ÎèåÏïÑÍ∞ÄÍ∏∞</Button>
        </div>
      </div>
  );
  }

  return (
    <div className="min-h-screen bg-gray-50">
        <SessionHeader
        isQuizMode={false}
        currentSign={"Ïë§ÌçºÎÖ∏Î∞î"}
        chapter={"chaptar"}
        currentSignIndex={1}
        progress={progress}
        categoryId={undefined}
        navigate={navigate}
      />

      <main className="container mx-auto px-4 py-8">
        <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
          {qors.current?(<div className="space-y-6">
            <Card>
              <CardHeader>
                <CardTitle>ÌòÑÏû¨ Î¨∏Ï†ú</CardTitle>
              </CardHeader>
              <CardContent>
                <div ref={decref} className="text-5xl text-center font-bold" />
                <div ref={timeref} className="text-center text-gray-600 mt-2" />
                <div ref={pileref} className="text-center text-3xl mt-4" />
              </CardContent>
            </Card>
          </div>):(<div className="space-y-6">
            <Card>
              <CardHeader>
                {setType === 'consonant'?(<CardTitle>ÏûêÏùå Ïó∞Ïäµ</CardTitle>):
                (<CardTitle>Î™®Ïùå Ïó∞Ïäµ</CardTitle>)}
{/* Îπà Ìä∏ÎûôÏùÄ Ìï≠ÏÉÅ */}
<div className="mt-2">
  <div className="w-full bg-gray-200 rounded-full h-2.5">
    {/* Ï±ÑÏõåÏßÄÎäî Î∂ÄÎ∂ÑÏùÄ progressPercentÏóê Îî∞Îùº ÎÑìÏù¥Îßå Î≥ÄÌï® */}
    <div
            className="bg-blue-600 h-2.5 rounded-full transition-all duration-[800ms] ease-linear"
      style={{ width: `${progressPercent}%` }}
    />
  </div>

  {/* Ïù∏Ïãù Ï§ë ÌÖçÏä§Ìä∏Îßå ÌôúÏÑ± ÏÉÅÌÉúÏóêÏÑú ÎÖ∏Ï∂ú */}
  {gestureRecognitionActive && (
    <div className="text-xs text-center mt-1 text-gray-500">
      Ïù∏Ïãù Ï§ë...
    </div>
  )}
  </div>
                                
              </CardHeader>
              <CardContent>
                <div ref={decref} className="text-5xl text-center font-bold" />
                  <LetterDisplay isVowel={setType !== 'consonant'} progress={currentIndex + 1}/>
                <div ref={pileref} className="text-center text-3xl mt-4" />
              </CardContent>
            </Card>
          </div>)}

          <div className="space-y-6">
            <Card>
              <CardHeader>
                <CardTitle>ÏÜê Î™®Ïñë Ïù∏Ïãù</CardTitle>
              </CardHeader>
              <CardContent className="flex flex-col items-center">
                <video ref={videoRef} style={{ display: 'none' }} autoPlay muted playsInline width="640" height="480" />
                <canvas ref={canvasRef} width="640" height="480" className="border border-gray-300"  style={{ transform: 'scaleX(-1)' }}/>
                <div ref={resultRef} className="text-center text-xl mt-4" />
              </CardContent>
            </Card>
          </div>
        </div>
      </main>
    </div>
  );
};

export default LetterSession;